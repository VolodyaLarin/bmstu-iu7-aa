\chapter{Аналитический раздел}\label{analyth}

\section{Сортировка пузырьком}

Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и если порядок в паре неверный (возрастание, в случае сортировки по убыванию, и наоборот), выполняется обмен элементов. Проходы по массиву повторяются $N−1$ раз. 

Также существует модифицированная версия данного алгоритма: добавляется флаг, которые показывает были ли обмены в данном цикле. Данный флаг показывает отсортирован ли массив.

\section{Сортировка вставками}

Сортировка вставками — алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов.

Массив условно делится на две части: отсортированную и требующую сортировки. В начальный момент отсортированная последовательность пуста. На каждом шаге алгоритма выбирается один из элементов входных данных и помещается на нужную позицию в уже отсортированной последовательности до тех пор, пока набор входных данных не будет исчерпан. В любой момент времени в отсортированной последовательности элементы удовлетворяют требованиям к выходным данным алгоритма

\section{Сортировка выбором}

Существует семейство сортировок, основанное на идее многократного выбора. Простейшая сортировка, основанная на следующей идее. Массив условно делится на две части: отсортированную и требующую сортировки.
Из правой части выбирается наименьший элемент и добавляется в конец отсортированной части с помощью обмена первого элемента не отсортированной части и минимального данной части.

\section{Требование к ПО}

Программа должна отвечать следующем требованиям:
\begin{enumerate}
	\item На вход подается длинна массива и массив чисел разделенные пробельным символом;
	\item ПО должно выводить отсортированный массив.
\end{enumerate}

\section{Вывод}
В данной работе стоит задача реализации 3 алгоритмов сортировки, а именно: пузырьком, вставками и выбором. Необходимо оценить трудоемкость алгоритмов и проверить ее экспериментально.